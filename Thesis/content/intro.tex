\chapter{Einführung}\label{ch:intro}

Das Smartphone ist heutzugtage der stete Begleiter eines Menschen. \enquote{Zwei Drittel der Bevölkerung und nahezu jeder 14- bis 29-Jährige geht darüber ins Netz.} \cite{usage} Auch die Prognose zeigt, das der Absatzmarkt immer weiter steigen wird (Abbildung \ref{fig:prognose_fig}).

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.86\textwidth]{images/prognose-zur-anzahl-der-smartphone-nutzer-weltweit-bis-2020.png}
		\caption{Prognose zur Anzahl der Smartphone-Nutzer weltweit von 2012 bis 2020 (in Milliarden) \cite{prognose}.}
		\label{fig:prognose_fig}
	\end{center}
\end{figure}

Umso wichtiger ist es das die Softwareentwicklung diesen Trend ernst nimmt. Der ehemalige Google-Chef Eric Schmidt sagte bereits 2010: \enquote{Googles Devise heißt jetzt \enquote{Mobile first}}. 
Diese Devise wird von vielen Unternehmen verfolgt, das ist der Grund weswegen in den einzelnen Stores heutzutage so viele Apps angeboten werden. Bei Android im Playstore sind es im Oktober 2016 ca. 2,4 Millionen Apps \cite{play_store}, bei Apple im App Store sind es ca. 2 Millionen Apps (Stand Juni 2016) \cite{app_store}. Neben Googles Android und Apples iOs gibt es noch andere Betriebssysteme, beispielsweise Microsofts Windows Phone oder Blackberrys Blackberrys OS. Jedoch bestimmen die beiden erstgenannten Systeme den Markt (Abbildung \ref{fig:os_fig}).

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.86\textwidth]{images/os.jpg}
		\caption{Der weltweite Marktanteil von Smartphone-Betriebssysteme. \cite{os}}
		\label{fig:os_fig}
	\end{center}
\end{figure}

Jede dieser Applikationen wurden einzeln für sich entwickelt und implementiert. Bei jedem Update zum Beispiel des Systems, müssen alle Anwendungen gewartet und überarbeitet werden, um die volle Funktionalität zu gewährleisten.

Würden einige Applikationen jedoch genauer analysiert werden, wäre das Ergebnis, dass in jeder dieser Anwendungen Codepassagen vorhanden sind, welche einen ähnlichen beziehungsweise den selben Zweck erfüllen. Werden diese Stellen im Programmcode abstrahiert, gibt es die Möglichkeit diese generieren zu lassen. Um Code generieren zu lassen, benötigt man so genannte Code-Generatoren. 

Im Bereich der Backend-Entwicklung gibt es bereits verschiedene Projekte die sich damit befassen. Ein Beispiel wäre der \textit{CRUD Admin Generator} \cite{generators}. Die Hochschule für angewandte Wissenschaften Würzburg-Schweinfurt entwickelt  unter der Leitung von Prof. Dr. Peter Braun auch einen Code-Generator unter dem Namen: \ac{gemara}. Mit Hilfe solcher Generatoren für den Bereich von Mobilen Applikationen, könnte der Entwicklungs- und Wartungsaufwand reduziert werden. 

Führt ein Systemupdate dazu, dass die Implementierung von verschiedenen Anforderungen nicht weiter funktionsfähig ist, muss dies nur einmalig an der entsprechenden Stelle im Code-Generator geändert werden und nicht in jeder Applikation einzeln. 

\section{Motivation}\label{sec:motivation}
Im Rahmen des Projektes \ac{gemara} gab es bereits Arbeiten, welche sich mit dem Thema der Generierung von Android Aktivities beschäftigt. Die dabei entstandenen Lösungen, resultieren darin, das dass generieren von Aktivities zu Problemen führt. Deshalb beschäftigt sich diese Ausarbeitung damit, nicht eine komplette Aktivity zu erzeugen, sondern sogenannte Komponenten.

Eine Komponente, ist im wesentlichen eine kleine Anwendung für sich, welche nur eine einzige Aufgabe erfüllt. Dies könnte zum Beispiel das Anzeigen eines Dozenten in einer Campus-Applikation sein.

Aus den erzeugten Komponenten, kann eine Art Bausatz entstehen. Mit dessen Hilfe der Entwickler seine Applikation zusammen bauen kann. Dabei wird ihm freie Wahl gelassen, wie der Aufbau seiner Anwendung aussieht, er bedient sich nur an gegebener Stelle an den Komponenten. Dadurch reduziert sich der Entwicklungsaufwand für ihn.

Bewegen wir uns in der Domain einer Hochschule, so kann eine Bibliothek mit den erzeugten Komponenten allen Studierenden zur Verfügung gestellt werden. Dadurch wäre jeder dieser Studierenden in der Lage eine persönliche Campus-Applikation zu entwickeln. Durch die einzelnen Komponenten kann dann sichergestellt werden, dass grundsätzliche Funktionalität bereits gewährleistet ist.

\section{Zielsetzung}\label{sec:target}
Ziel dieser Ausarbeitung liegt darin, dass der Leser ein grundsätzliches Verständnis für die Entwicklung von Android-Applikationen beziehungsweise Android-Bibliotheken vermittelt bekommt. Weiterhin soll das Wissen über Datenkommunikation mittels \ac{rest} vertieft werden. Hierbei wird ein Schwerpunkt auf das Hypermedia-Prinzip gelegt. 

Neben diesen spezifischen Anforderungen, soll ein Verständnis für der Implementierung von Generatoren entstehen. Dafür muss der Entwickler entscheiden können, was von der Implementierung als statischer Code angesehen werden kann und welcher generisch ist. Dieses Verständnis ist wichtig, um die Komplexität der Generatoren zu reduzieren. Da die statischen Anteile jedes mal identisch sind.

Auch soll auf die Frage eingegangen werden, ob man das \ac{ui}, welches ebenfalls generiert wird, auch generisch gestalten kann. Das bedeutet, dass nicht nur die Informationen, welche angezeigt werden sollen beschreibt. Sondern auch wie diese angezeigt werden sollen.

Wenn es möglich ist dass das \ac{ui} als Teil der \acf{dsl} beschrieben werden kann, so hat der Nutzer des entsprechenden Generators die Freiheit, selbst zu entscheiden ob zum Beispiel bei seiner Campus-App, bei der Liste aller Dozenten das Profilbild links oder rechts angezeigt werden soll.

\section{Aufbau der Arbeit}\label{sec:structure}
Diese Ausarbeitung ist in sieben Kapitel unterteilt. In der einführend wird zu Beginn auf den Stellenwert von Android Applikationen eingegangen. Darauf folgt die Motivation, weswegen diese Arbeit geschrieben wurde. Diese soll die Problemstellung anreißen und zur Zielsetzung hinführen. In diesem Teil der Einführung wird definiert, was der Sinn dieser Arbeit ist. Das Kapitel wird dann mit dem Bereich abgeschlossen, welchen den Bereich der Arbeit beschreibt.

Das zweite Kapitel befasst sich mit den Grundlagen. Hier soll der Leser noch einmal seinen Kenntnisstand über \acf{rest} auffrischen und die Bedeutung von \acf{hateoas} verstehen. Neben dem Bereich der Netzwerkkommunikation wird außerdem noch der Bereich Android angeschnitten. Hier liegt der Schwerpunkt in der Entwicklung und CustomViews. Dabei werden die einzelnen Schritte aufgezeigt, die benötigt werden um diese Komponenten zu erstellen und zu benutzen. Der letzte Teil in den Grundlagen befasst sich mit Software-Generatoren. Hier wird dem Leser kurz erklärt was eine \acf{dsl} ist und welche zwei große Arten es gibt.
Zum Anschluss wird das Projekt \acf{gemara} vorgestellt. 

Im folgenden Kapitel wird die Problemstellung behandelt, die das Design und die Implementierung eines Software-Generators für Android Applikationen mit sich bringen. Es werden Fragen aufgeworfen, welche beim Design des Meta-Modells beachtet werden müssen, oder wie man spezifisches Android Verhalten in einer \ac{dsl} beschreiben kann. Abgeschlossen wird dieses Kapitel mit den Fragen zum Design des Software-Generators selbst. Es werden Besonderheiten und Abhängigkeiten aufgezeigt, welche beim Design des Generators berücksichtigt werden müssen.

Das Kapitel Problemstellung soll auf das darauf folgende Kapitel Lösung hinführen. In welchem mögliche Lösungsvorschläge präsentiert werden und auf deren Vor- und Nachteile eingegangen wird. Eingeleitet wird das Kapitel mit dem Meta-Modell. Es wird darauf die Anforderungen an dieses eingegangen und anschließend zwei Modelle vorgestellt. Ein reines Android Modell und dann die Erweiterung des vorhandenen Enfield-Modells. Der nächste Bereich befasst sich mit der Analyse, hierbei soll herausgefunden werden welche Daten das Meta-Modell überhaupt benötigt. In der Analyse werden die einzelnen Views genauer betrachtet und es wird ein Augenmerk auf den Programmablauf und die Aktionen bei Klick gelegt. Nach der Analyse wird der Aufbau der View-Meta-Modelle vorgestellt. Bei jeder View wird auf deren Besonderheit und Möglichkeiten eingegangen. Neben den View-spezifischen Daten wird auch noch aufgezeigt, welche Dateien allgemein benötigt werden und wo diese im vorgegebenen Modell platziert werden sollten. Nachdem das Meta-Modell ausreichend vorgestellt wurde widmet sich das Kapitel Lösung dem Software-Generator. Hier wird zunächst das \acf{api} JavaPoet im Zusammenhang mit der Generierung von Java-Klassen vorgestellt, anschießend wird beschrieben, wie andere Datei-Typen generiert werden können. Nachdem bekannt ist wie die einzelnen Dateien generiert werden können, wird auf den Aufbau der zu generierenden Applikation eingegangen. Es wird gezeigt welche Features unterstützt werden müssen, und wie die Applikation im Bezug auf Abstraktion und Einteilung generell auszusehen habt. Ist der Aufbau der Applikation bekannt wird der Aufbau des Generators vorgestellt. Es wird auf die einzelnen Bereiche eingegangen und deren Aufgabe und Funktionsweise erklärt. Abgeschlossen wird das Kapitel mit einer Anleitung, wie die generierte Applikation gebaut und ausgeführt werden kann.

Das fünfte Kapitel Evaluierung anhand einer Beispielanwendung, ist in drei Bereiche eingeteilt. Am Anfang wird die Beispielanwendung vorgestellt. Anschließend wird auf die Erstellung und Nutzung des Meta-Modells eingegangen, wobei hier auch Einschränkungen durch dieses aufgezeigt werden. Der letzte Bereich befasst sich dann noch einmal mit den Zeitaufwänden und der Komplexität der Entwicklung, Wartung und Nutzung des Generators. Auch wird die Komplexität der erzeugen Applikation kritisch bewertet.

In den letzten beiden Kapitel Zusammenfassung und Ausblick, wird die Arbeit noch einmal Revue passieren lassen. Es werden auch noch mögliche Erweiterungen und Ergänzungen an Meta-Modell und Software-Generator vorgestellt.