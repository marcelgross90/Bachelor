\chapter{Grundlagen}\label{ch:basics}
\section{\acf{rest}}\label{sec:rest}
In dem generierten Projekt, sollen alle benötigten Daten mittels \ac{rest} von dem zugehörigen, generierten Backend geladen werden. 

\ac{rest} \cite{rest_fielding} ist ein Programmierparadigma, welches sich auf folgende Prinzipien stützt:


\begin{enumerate}
	\item  Client-Server
	\item  Zustandslose Kommunikation
	\item  Caching
	\item  Uniform Interface
	\item  Layered System
	\item  Code-on-Demand (optional)
\end{enumerate}

\subsection{\acf{hateoas}}\label{sec:hateoas}
\ac{hateoas} fällt unter das Prinzip Uniform Interface. Es beschreibt, wie mit Hilfe eines endlichen Automaten eine \ac{rest}-Architektur entworfen werden kann.

Der Architekt einer \ac{rest}-konformen \acf{api} überlegt sich im vorraus, wie der Applikation-Fluss in der späteren Anwendung aussehen soll. Dafür definiert er verschiedene States und welche Transitionen zum nächsten State führen.

Als ein State kann beispielsweise das Anzeigen aller Lecturer in einer Campus-Applikation angesehen werden.
Die Transition hingegen ist zum Beispiel ein Link im Link-Header der Antwort, oder ein Attribut, der empfangen Ressource. 

Wird das \ac{api} mit Hilfe eines endlichen Automaten entwickelt, kann diese dem Client-Entwickler als Anleitung zum erstellen seines Clients dienen. Er benötigt lediglich einen \acf{url}, welcher auf den initialen State des endlichen Automaten führt. Dieser liefert dann alle, zu diesem Zeitpunkt möglichen, Transitionen zurück. Mit Hilfe dieser Transitionen, kann sich der Entwickler dann zum nächsten State bewegen. Auch dieser State liefert neben den Ressourcen, alle möglichen weiteren Transaktionen zurück. 
Wenn der Entwickler sich so durch die States bewegt, bekommt er die benötigten Informationen zum Aufbau und Ablauf der Applikation.

Die Abbildung \ref{finite_state_machine} zeigt einen solchen Automaten. Der Einstiegspunkt ist der State \enquote{Dispatcher} dieser liefert die Tansition zum State \enquote{Collection} zurück. Dieser State, verfügt über alle Informationen die benötigt werden um eine Collection der betroffenen Ressource anzuzeigen, weiterhin verfügt er auch das Wissen, über die beiden nächsten Transitionen zu den States \enquote{Create} und \enquote{Single}. Wie der Name des States annehmen lässt, wird der State \enquote{Create} benötigt um eine neue Ressource anzulegen. Von diesem State aus kann die Anwendung nur zurück zum State \enquote{Collection}. Der State \enquote{Single} enthält alle benötigten Daten um eine einzelne Ressource anzuzeigen. Vom hier kann die Anwendung zum State \enquote{Update} oder \enquote{Delete} wechseln. Der State \enquote{Update} ermöglicht es die Ressource zu bearbeiten. Von hier kann der Nutzer der Anwendung nur zum State \enquote{Single} zurückkehren. Der State \enquote{Delete} löscht die aktuelle Ressource und liefert die Transition zum State \enquote{Collection} zurück. 
Dieses Beispiel verdeutlich nocheinmal bildlich, das der Entwickler nur den Einstiegspunkt \enquote{Dispatcher} kennen muss. Die Anwendung liefert selbst alle benötigten Informationen um die Daten für die Anwendung nachzuladen.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
		semithick]
		\tikzstyle{every state}=[fill=none,text=black]
		
		\node[initial,state] (A) [minimum width=3cm]             {Dispatcher};
		\node[state]         (B) [right of=A, minimum width=2cm] {Collection};
		\node[state]         (D) [below of=B, minimum width=2cm] {Create};
		\node[state]         (C) [right of=B, minimum width=2cm] {Single};
		\node[state]         (E) [above of=C, minimum width=2cm] {Delete};
		\node[state]		 (F) [below of=C, minimum width=2cm] {Update};
		
		\path 
		(A) edge             (B)
		(B) edge [bend left] (C)
			edge [bend left] (D)
		(C)	edge 			 (E)
			edge [bend left] (B)
			edge [bend left] (F)
		(D) edge [bend left] (B)
		(E) edge   			 (B)
		(F) edge [bend left] (C);
		
		\end{tikzpicture}
			\caption[Aufbau eines \acl{rest}-\acl{api} mit Hilfe eines endlichen Automaten.]{Aufbau eines \ac{rest}-\ac{api} mit Hilfe eines endlichen Automaten.}
		\label{fig:finite_state_machine}
	\end{center}
\end{figure}

\section{Android}\label{sec:android}
Die Software-Plattform Android basiert auf Linux und wird als Betriebsystem für mobile Endgeräte verwendet.
Das System wird als Open Source Projekt von der Open Handset Alliance entwickelt \cite{open_handset_alliance}. Dabei ist ein Ziel, die Schaffung eines offenen Standarts für mobile Endgeräte.
Die Entwicklung ist nicht abgeschlossen, die aktuelle Version ist 7.0 Nougat (Stand Feb. 2017).

Programme für diese Plattfrom nennt man Applikationen oder kurz Apps. Eine App stellt alle nötigen Sourcen bereit, zum Beispiel den Programmcode, Layout und Grafiken, die benötigt werden, um diese App auf einem Android-Endgerät auszuführen.

\subsection{Custom Views}
Mit Hilfe von Widgets und Layouts können Views definiert werden. Diese Views stellen dann die gewünschte Information auf dem Display dar. Die bekanntesten Widgets sind: TextView, Button und EditText. Die Anordnung dieser Widgets erfolgt dann mit einem Layout. Es gibt hierbei verschiendene Layouts zur Auswahl. Beispielsweise das LinearLayout, mit horizontaler oder vertikaler Orientierung. Ein weiteres Beispiel ist das RelativeLayout.

Reichen die Standart-Layouts und -Widgets nicht aus, gibt es noch die Möglichkeit eigene zu entwickeln. Dies ermöglicht diese Views um Attribute und Methoden zu erweitern. Diese können dann sowohl in der Layout-XML als auch im Programm-Code angesprochen werden.

Ausgehend davon das eine Applikation eine Liste von Personen mit Hilfe einer RecyclerView anzeigen soll, gibt es die Möglichkeit eine CardView zu erzeugen, welche eine einzelne Person darstellt. Diese CardView kann in einem XML-Layout wie allgemein bekannt definiert werden. Um die View dann mit den entsprechenden Informationen zu befüllen werden im Adapter der ListView dann die einzelnen Attribute einzeln angesprochen und mit den erforderlichen Details befüllt.

Alternativ besteht die Möglichkeit eine Custom-View zu erzeugen, in diesem Fall eine PersonCardView.
Hierfür sind folgende Schritte notwendig:

\subsubsection{Registrieren der Custom-View}
Zur Erzeugung und Registrierung von Custom-Views wird eine Datei \enquote{attrs.xml} benötigt. Diese wird liegt im Ordner \enquote{values} im Verzeichnis \enquote{res}. 
In dieser XML-Datei werden im \enquote{resoruces}-Bereich die einzelnen Custom-Views aufgelistet. Es besteht die Möglichkeit diesen Views zusätzlich Attribute zuzuweisen. Ein Attribut besteht dabei immer aus einem Namen und einem Format. Dieses Format definiert den erwarteten Eingabewert. Es gibt folgende definierte Formate: string, integer, boolean oder color. 
Formate können kombiniert werden. Beispielsweise das Attribut \enquote{backgroundColor} könnte so definiert werden format=\enquote{color|string}. Listing \ref{lst:attrs} zeigt den Aufbau einer \enquote{attrs.xml}-Datei.

\begin{lstlisting}[label=lst:attrs,
language=xml,
firstnumber=1,
caption=Aufbau einer \enquote{attrs.xml} - Datei]				   
<resources>
	<declare-styleable name="AttributeInput">
		<attr name="hintText" format="integer"/>
		<attr name="inputType" format="string"/>
	</declare-styleable>
	
	<declare-styleable name="PersonCardView" />
</resources>
\end{lstlisting}

\subsubsection{Definieren des Aufbaus der PersonCardView}

Da die PersonCardView eine Custom-View ist, welche aus verschiedenen Widgets zusammengesetzt wurde, müssen diese auch definiert werden. Dies geschieht wie gewohnt mit Hilfe einer XML-Datei, mit einer Ausnahme. Die Root-View ist in diesem Fall keine CardView sondern ein beliebiges anderes Layout. Da die PersonCardView von CardView erbt und somit bereits eine CardView ist.

\begin{lstlisting}[label=lst:personCardViewXml,
language=xml,
firstnumber=1,
caption=Aufbau der PersonCardView mit Hilfe einer XML-Datei]				   
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
	android:id="@+id/relativeLayout"
	android:layout_width="match_parent"
	android:layout_height="wrap_content">

	<TextView
		android:id="@+id/first_name"
		android:layout_width="wrap_content"
		android:layout_height="wrap_content"
		android:text="@string/firstName"/>

	<TextView
		android:id="@+id/last_name"
		android:layout_width="wrap_content"
		android:layout_height="wrap_content"
		android:text="@string/last_name"/>

...

</RelativeLayout>
\end{lstlisting}

\subsubsection{Erzeugen einer PersonCardView Klasse}

Hierfür wird eine neue Java-Klasse erzeugt, welche von CardView erbt. Es kann auch direkt von der View-Klasse geerbt werden und anschließend mithilfe der Methode \enquote{onDraw}, welche überschrieben werden muss, den gewünschten Inhalt anzueigen. Sei es nun Text, Formen oder Benutzereingaben.
In diesem Fall entspricht die CardView weitestgehend bereits den Anforderungen, so das diese genutzt wird.
Die Vererbungsstruktur bringt mit sich, das die Konstruktoren der CardView implementiert werden müssen.
Die Anzahl dieser Konstruktoren hängt von der Minimum SDK-Versions des Projekts ab. Dieses Projekt nutzt das Minimum Level 12 somit müssen drei Konstrukotoren überschrieben werden. Ab einen Level von 21, sind es vier, da ein weiteres Attribut zur View hinzugefügt wurde.

\begin{lstlisting}[label=lst:personCardView,
language=java,
firstnumber=1,
caption=Konstruktoren der PersonCardView]				   
public class PersonCardView extends CardView {

public PersonCardView(Context context) {
	super(context);
	init(context, null, 0);
}

public PersonCardView(Context context, AttributeSet attrs) {
	super(context, attrs);
	init(context, attrs, 0);
}

public PersonCardView(Context context, AttributeSet attrs, int defStyleAttr) {
	super(context, attrs, defStyleAttr);
	init(context, attrs, defStyleAttr);
}
...
}
\end{lstlisting}

Innerhalb der \enquote{init}-Methode wird definiert, was die View anzeigen beziehungsweise was sie tun soll. 
In diesem Beispiel werden die verwendeten Widgets initialisiert. Besässe die PersonCardView noch eigene Attribute, so würden diese im AttributeSet übergeben und könnten daraus in ein TypedArray geschrieben werden. Dieses TypedArray muss am Ende \enquote{recycled} werden, damit es für einen späteren Aufruf wieder zur Verfügung steht.

Jetzt wird die PersonCardView um eine Methode \enquote{setPerson} erweitert. Diese ist angelehnt an die Methode \enquote{setText} der TextView. Sie ermöglicht das der PersonCardView ein Objekt Person übergeben wird und füllt dann die entsprechenden Widgets mit den dazugehörigen übergebenen Daten.

\begin{lstlisting}[label=lst:setPerson,
language=java,
firstnumber=1,
caption=\enquote{setPerson} - Methode aus der PersonCardView]				   
public void setPerson(Person person) {
	this.firstName.setText(person.getFirstName());
	this.lastName.setText(person.getLastName());	
	...
}
\end{lstlisting}

Mit Hilfe dieser Methode wird die Nutztung der PersonCardView vereinfacht. Im Adapter der RecyclerView wird jetzt nicht mehr jedes einezelne Widget definiert und mit Informationen befüllt. Sondern nur noch die PersonCardView und mit der \enquote{setPerson} - Methode kann die komplette Karte mit den Daten einer Peron mit nur einem Methodenaufruf befüllt werden.

\section{Generatoren}\label{sec:generators}
\subsection{\acf{gemara}}\label{sec:gemara}